Experimental bytecode to machine code compiler

CPython 3.2 is required. Higher versions might work, but since the Python
bytecode can vary from version to version, it's completely hit or miss.

The compiler supports the x86 and x86-64 instruction sets.

Currently only the following bytecode instructions are implemented:
BINARY_MULTIPLY
BINARY_TRUE_DIVIDE
BINARY_FLOOR_DIVIDE
BINARY_SUBTRACT
BINARY_SUBSCR
BINARY_LSHIFT
BINARY_RSHIFT
BINARY_AND
BINARY_XOR
BINARY_OR
INPLACE_MULTIPLY
INPLACE_TRUE_DIVIDE
INPLACE_FLOOR_DIVIDE
INPLACE_MODULO
INPLACE_SUBTRACT
INPLACE_LSHIFT
INPLACE_RSHIFT
INPLACE_AND
INPLACE_XOR
INPLACE_OR
POP_TOP
LOAD_NAME
STORE_NAME
DELETE_NAME
LOAD_GLOBAL
STORE_GLOBAL
LOAD_CONST
CALL_FUNCTION
RETURN_VALUE
SETUP_LOOP
POP_BLOCK
GET_ITER
FOR_ITER
JUMP_ABSOLUTE
LOAD_ATTR
POP_JUMP_IF_FALSE
POP_JUMP_IF_TRUE
BUILD_LIST
BUILD_TUPLE
STORE_SUBSCR
MAKE_FUNCTION
MAKE_CLOSURE
LOAD_FAST
STORE_FAST
UNPACK_SEQUENCE
UNPACK_EX
COMPARE_OP
JUMP_FORWARD
RAISE_VARARGS
BUILD_MAP
STORE_MAP
MAP_ADD

BINARY_ADD and INPLACE_ADD are also implemented but currently lack an
optimization on strings that CPython normally does.


Basic Usage:

>>> import nativecompile
>>> bcode = compile('print("Hello World!")','<string>','exec')
>>> mcode = nativecompile.compile(bcode)
>>> mcode()
Hello World!


This is a very unsophisticated compiler. The bytecode is translated into the
equivalent machine code with no optimizations (almost; some push and pop
instructions can be eliminated by using registers instead). However, this does
remove the overhead of the interpreter loop and thus should result in a modest
performance boost.


Implementation note:

Since code and function objects cannot be subclassed, the most significant bit
in co_flags in a PyCodeObject is used by this package to indicate the presence
of compiled code instead.

Even if defined inside compiled code, functions called outside of compiled code
will always run the bytecode and not the machine code. Additionally, functions
defined outside of compiled code do not get compiled, even if called inside
compiled code.
