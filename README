Experimental bytecode to machine code compiler

CPython 3.2 is required. Higher versions might work, but since the Python
bytecode can vary from version to version, it's completely hit or miss.

The compiler supports the x86 and x86-64 instruction sets.

The following bytecode instructions are not yet implemented:
BINARY_MODULO
BINARY_POWER
BUILD_SET
BUILD_SLICE
CALL_FUNCTION_KW
CALL_FUNCTION_VAR
CALL_FUNCTION_VAR_KW
DELETE_DEREF
DUP_TOP_TWO
INPLACE_POWER
JUMP_IF_FALSE_OR_POP
JUMP_IF_TRUE_OR_POP
LIST_APPEND
LOAD_CLOSURE
LOAD_DEREF
PRINT_EXPR
ROT_THREE
ROT_TWO
SETUP_WITH
SET_ADD
STORE_DEREF
WITH_CLEANUP
YIELD_VALUE


Basic Usage:

>>> import nativecompile
>>> bcode = compile('print("Hello World!")','<string>','exec')
>>> mcode = nativecompile.compile(bcode)
>>> mcode()
Hello World!


Compiling Modules:

By default, imported modules are not compiled. To have modules automatically
compiled, the nativecompile.importer module supplies the function
install_importer. install_importer must be called before any module you wish to
compile is imported for the first time. It makes no difference whether the
module is imported inside or outside of compiled code. The compiling importer
can be removed with uninstall_importer.

Usage:

>>> import nativecompile
>>> import nativecompile.importer
>>> nativecompile.importer.install_importer()
>>> import mymodule
>>> bcode = compile('mymodule.myfunction()','<string>','exec')
>>> mcode = nativecompile.compile(bcode)
>>> mcode()

Calling install_importer will install a path hook (see
http://www.python.org/dev/peps/pep-0302 for details) that handles any python
module inside a folder (the hook does not currently handle modules inside ZIP
files). Any module that is handled by another path or meta-path hook will not be
compiled (but will still run).

The compiled code from a module is stored in the module's globals under the name
__nativecompile_compiled_code__. If this object is deleted, the compiled code
will be gone, but the bytecode will remain and everything in the module will
still work. The variable is never referenced after being set, so as long as you
preserve the compiled code object, the name can be reassigned to or unset
without affecting the compiled code.


This is a very unsophisticated compiler. The bytecode is translated into the
equivalent machine code with no optimizations (almost; some push and pop
instructions can be eliminated by using registers instead). However, this does
remove the overhead of the interpreter loop and thus should result in a modest
performance boost.


Implementation note:

Since code and function objects cannot be subclassed, the most significant bit
in co_flags in a PyCodeObject is used by this package to indicate the presence
of compiled code instead.
